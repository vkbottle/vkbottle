# Применение валидаторов

Валидаторы - штуки, контроллирующие прохождения аргументов под шаблон сообщения. Давайте напишем простую обработку сообщения с простым аргументом

```python
@bot.on.message_both('мне <some> лет', lower=True)
async def wrapper(ans: Message, some: typing.Any):
    await ans(f'Все ясно! @id{ans.from_id} (этому человеку) {some} лет')
```

Теперь реакция бота на сообщения шаблона `мне 5 лет` будет указанным сообщением. Но вот проблема! Мы не можем контроллировать вхождение аргумента, точнее мы можем, но только применяя условие с проверкой на `isdigit()` и какими-то другими заморочками.

**Валидаторы!** Вот то что нам нужно. С помощью них мы сможем контроллировать вхождения аргументов по определенным условиям с помощью встроенного в модуль патчера (`VKBottle Patcher v0.2`)  и собственного языка разметки основанного на regex - VBML (VKBottle Marking Language).

### Изучаем аргументы сообщений с точки зрения VBML

VBML - простой язык разметки на regex, то что нам нужно ведь в него встроена валидация для аргументов.

Для того присвоить аргументу валидатор нужно указать его после названия аргумента, например так:

`<some:validator>`

Проверьте работу VBML прямо сейчас. Создайте обработчик с указанным кодом прямо сейчас:

```python
@bot.on.message_both('<some:validator>', lower=True, command=True)
async def wrapper(ans: Message, some: typing.Any):
    await ans(f'Введена команда {some}!')
```

Теперь при итерировании этого обработчика `some` будет проверяться по валидатору `validator`.

Этот самый `validator` является тестовым валидатором и просто скажет вам о том, что все работает правильно, а именно валидация VBML.

**Вы можете использовать несколько валидаторов, даже одинаковых сразу**

`<some:validator:validator2>`

### Встроенные валидаторы

Класс со встроенными валидаторами вы можете увидеть [здесь](../vkbottle/framework/patcher/validators/vbml.py).

На данный момент встроенными работающими валидаторами для аргументов являются:

| Название | Применение     | Описание                                                                                              |
|:--------:|:--------------:|:-----------------------------------------------------------------------------------------------------:|
| int      | `<some:int>`   | Проверяет аргумент на то, что он является целым числом и в данном варианте возвращает его в этом типе |
| float    | `<some:float>` | Принимает числа и целые, и с плавающей точкой. Возвращает в типе float                                |
| url      | `<some:url>`   | Проверяет аргумент на прибывание ссылкой с протоколом (http или http(s)). Использует urllib.urlparse для проверки        |

### Создание собственных валидаторов

Главной фишкой валидаторов является не использование трех стандартных, а создание собственных. Я хочу учесть кое-какую особенность, пользуясь этим свойством патчера.

Давайте создадим кастомный класс собственных валидаторов, наследуя стандартный класс `VBMLValidators`:

```python
from vkbottle.validators import VBMLValidators
# bot = Bot(...)

class MyValidators(VBMLValidators):
    pass

bot.patcher(validators=MyValidators)
```

Теперь мы можем создавать собственные валидаторы. При создании валидаторов вам нужно придеживаться нескольких правил оформления:

* Функции валидаторов должны быть асинхронными

* Фунции должны быть методами класса (не staticmethod) и содержать один аргумент, который будет принимать валидируемый аргумент

* Аргумент будет считаться правильным если валидатор вернет все что угодно кроме `None`.

* Не `None` возвращение валидатора и будет возвращаться в хендлер

Я собираюсь учесть проблему, где, благодаря трудностям славянских языков для указания возраста мы можем использовать и `лет`, и `года`, и `год`

```python
class MyValidators(VBMLValidators):
    async def years(self, text: str):
        if text in ['лет', 'года', 'год']:
            return text
        return  # https://docs.python.org/3.7/reference/simple_stmts.html#the-return-statement
```

Теперь напишу конечный обработчик:

```python
@bot.on.message_both('мне <years:int> <y_rep:years>', lower=True)
async def wrapper(ans: Message, years: int, y_rep: str):
    assert isinstance(years, int)
    assert isinstance(y_rep, str)
    if years >= 18:
        await ans(f'Ого тебе уже {years} {y_rep}')
    else: 
        await ans(f'Эм тебе еще только {years} {y_rep}')
```

Ура!

## Аргументы валидаторов

Создам простой валидатор startswith для аргументов, для этого в класс MyValidators добавлю новый обработчик:  

```python
async def startswith(self, value: str, start: str):
    if value.startswith(start):
        return value
```

Теперь я могу использовать этот валидатор:

```python
@bot.on.message_both('президент <name:startswith[Ким]>', lower=True)
async def wrapper(ans: Message, name: str):
    assert name.startswith("Ким")
    await ans(f'Да да! Президент {name}.')
```

* Аргументов может быть много, они перечисляются через запятую без пробелов.  
* Если аргумент цифра - он автоматически в нее конвертируется.
* Стандартный тип аргумента `int`.
